<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>query_template (caqti.query_template)</title><link rel="stylesheet" href="../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="index.html">Up</a> â€“ <a href="index.html">caqti</a> &#x00BB; query_template</nav><header class="odoc-preamble"><h2 id="the-syntax-of-query-templates"><a href="#the-syntax-of-query-templates" class="anchor"></a>The Syntax of Query Templates</h2><p>In order to help even out common difference between database systems and provide additional features, Caqti uses a lightweight template syntax parsed into the internal form <a href="Caqti_query/index.html#type-t"><code>Caqti_query.t</code></a> by the <a href="Caqti_query/index.html#val-angstrom_parser"><code>Caqti_query.angstrom_parser</code></a> and related utility functions. Query strings are written almost as you expect them to be sent to the database, but with some in-text special syntax.</p></header><nav class="odoc-toc"><ul><li><a href="#semicolon-and-end-of-input">Semicolon and End-of-Input</a></li><li><a href="#parameter-references">Parameter References</a></li><li><a href="#environment-references">Environment References</a></li><li><a href="#quotes">Quotes</a></li></ul></nav><div class="odoc-content"><h3 id="semicolon-and-end-of-input"><a href="#semicolon-and-end-of-input" class="anchor"></a>Semicolon and End-of-Input</h3><p>The <a href="Caqti_query/index.html#type-t"><code>Caqti_query.t</code></a> type represents a single statement. To allow reading statements from a script file and sending them to database one by one, the parser will stop at the first <a href="#quotes">unquoted</a> semicolon, as well as at the end of input. The semicolon itself will not be parsed, but you can create your own parser from the <a href="Caqti_query/index.html#val-angstrom_parser"><code>Caqti_query.angstrom_parser</code></a> which does.</p><h3 id="parameter-references"><a href="#parameter-references" class="anchor"></a>Parameter References</h3><p>Parameters are specified as either</p><ul><li><code>&quot;?&quot;</code> for linear substitutions (like Sqlite and MariaDB), or</li><li><code>&quot;$1&quot;</code>, <code>&quot;$2&quot;</code>, ... for non-linear substitutions (like PostgreSQL).</li></ul><p>Either case works independent of the style used by the database system; if non-linear substitutions are used with a database system which does not support it, the parameter values will be reorderd and duplicated as needed. Mixing the two styles in the same query string is not permitted. Note that numbering of non-linear parameters is offset by one compared to <a href="Caqti_query/index.html#type-t.P"><code>Caqti_query.t.P</code></a>, in order to be consistent with PostgreSQL conventions.</p><p>The following characters are not permitted immediately after a <code>?</code> reference:</p><pre><code>  'A'..'Z' | 'a'..'z' | '0'..'9' | '_'
| '!' | '&quot;' | '#' | '$' | '%' | '&amp;' | '\'' | '.' | ':'
| '&lt;' | '=' | '&gt;' | '?' | '@' | '^' | '`' | '|' | '~'</code></pre><p><a href="#quotes">Quotes</a> are not scanned for parameter references, to avoid accidental transformation of string literals within query strings.</p><h3 id="environment-references"><a href="#environment-references" class="anchor"></a>Environment References</h3><p>Functions processing queries take an <code>?env</code> argument which provides substitutions for the references which can have one of the following syntaxes:</p><ul><li><code>&quot;$(&lt;var&gt;)&quot;</code> is substituted by <code>env driver_info &quot;&lt;var&gt;&quot;</code>.</li><li><code>&quot;$(&lt;var&gt;.)&quot;</code>, if not found by the first rule, is substituted by <code>env driver_info &quot;&lt;var&gt;&quot;</code> followed by a dot iff that result is nonempty.</li><li><code>&quot;$&lt;var&gt;.&quot;</code> is a shortcut for <code>&quot;$(&lt;var&gt;.)&quot;</code>.</li></ul><p>These aid in substituting configurable fragments into the queries, like database schemas or table names. The forms involving a period are suggested for qualifying tables, sequences, and other database objects with the database schema.</p><p>Environment references are not parsed inside quotes, except for one kind; see <a href="#quotes">Quotes</a> for details.</p><h3 id="quotes"><a href="#quotes" class="anchor"></a>Quotes</h3><p>In order to avoid accidental conversion of parameter references or undesired expansion of environment lookups, the parser recognizes several kinds of quotations used by database systems. The following common kinds of quotations are recognized:</p><ul><li><code>'&lt;text&gt;'</code> where <code>'</code> may be escapes as <code>''</code></li><li><code>&quot;&lt;text&gt;&quot;</code> where <code>&quot;</code> may be escaped as <code>&quot;&quot;</code></li><li><code>`&lt;text&gt;`</code> with no escape mechanism</li></ul><p>In addition the parser recognizes PostgreSQL style tagged quotations:</p><ul><li><code>$&lt;tag&gt;$&lt;text&gt;$&lt;tag&gt;$</code> where the tag has the form of an identifier</li><li><code>$$&lt;text&gt;$$</code> as above but with an emtpy tag</li></ul><p>The former is treated like the other quotations, i.e. the text inside is passed on as-is. In the latter form, environment references are expanded, while parameter references are not recognized.</p><p>The motivation for this exception is that dollar quotes are often used in PostgreSQL schemas to define saved procedures, where it is useful to substitute schema names and possibly other code fragments. On the other hand, the dollar quotes are useful for other purposes, and when a tag is provided, whether it is around a saved procedure or elsewhere, it is typically to avoid a clashes with dollar signs in the text. Therefore, the exception to expand environment references is only made for the tagless variant of the dollar quotes.</p><p>Note that nested quotes are not recognized inside <code>$$&lt;text&gt;$$</code>, so substitutions apply unconditionally. That is, the <code>$(x)</code> substring will</p><ul><li>in <code>SELECT '$(x)'</code> be interpreted literally due to the single quotes, and</li><li>in <code>$q$SELECT '$(x)'$q$</code> be interpreted literally due to the tagged quotes, but will</li><li>in <code>$$SELECT '$(x)'$$</code> be expanded.</li></ul></div></body></html>